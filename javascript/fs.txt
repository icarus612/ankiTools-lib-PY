<b>Fs property</b> used to a <FileHandle> object is an object wrapper for a numeric file descriptor. instance of the <FileHandle> object are created by the fsPromises.open()method. all <FileHandle> objects are <EventEmitter>s. if a <FileHandle> is not closed using the filehandle.close() method, it willtry to automatically close the file descriptor and emit a process warning,helping to prevent memory leaks. Please do not rely on this behavior becauseit can be unreliable and the file may not be closed. Instead, always explicitlyclose <FileHandle>s. Node.js may change this behavior in the future. | FileHandle 
<b>Fs method</b> used to test a user's permissions for the file or directory specified by path.The mode argument is an optional integer that specifies the accessibilitychecks to be performed. mode should be either the value fs.constants.F_OKor a mask consisting of the bitwise OR of any of fs.constants.R_OK,fs.constants.W_OK, and fs.constants.X_OK (e.g.fs.constants.W_OK | fs.constants.R_OK). Check File access constants forpossible values of mode. if the accessibility check is successful, the promise is resolved with novalue. If any of the accessibility checks fail, the promise is rejectedwith an <Error> object. The following example checks if the file/etc/passwd can be read and written by the current process. using fsPromises.access() to check for the accessibility of a file beforecalling fsPromises.open() is not recommended. Doing so introduces a racecondition, since other processes may change the file's state between the twocalls. Instead, user code should open/read/write the file directly and handlethe error raised if the file is not accessible. | fsPromises.access(<i>path[, mode]</i>) 
<b>Fs method</b> used to asynchronously append data to a file, creating the file if it does not yetexist. data can be a string or a <Buffer>. if options is a string, then it specifies the encoding. the mode option only affects the newly created file. See fs.open()for more details. the path may be specified as a <FileHandle> that has been openedfor appending (using fsPromises.open()). | fsPromises.appendFile(<i>path, data[, options]</i>) 
<b>Fs method</b> used to change the permissions of a file. | fsPromises.chmod(<i>path, mode</i>) 
<b>Fs method</b> used to change the ownership of a file. | fsPromises.chown(<i>path, uid, gid</i>) 
<b>Fs method</b> used to asynchronously copies src to dest. By default, dest is overwritten if italready exists. no guarantees are made about the atomicity of the copy operation. If anerror occurs after the destination file has been opened for writing, an attemptwill be made to remove the destination. | fsPromises.copyFile(<i>src, dest[, mode]</i>) 
<b>Fs method</b> used to   asynchronously copies the entire directory structure from src to dest,including subdirectories and files. when copying a directory to another directory, globs are not supported andbehavior is similar to cp dir1/ dir2/. | fsPromises.cp(<i>src, dest[, options]</i>) 
<b>Fs method</b> used to change the permissions on a symbolic link. thi method is only implemented on macOS. | fsPromises.lchmod(<i>path, mode</i>) 
<b>Fs method</b> used to change the ownership on a symbolic link. | fsPromises.lchown(<i>path, uid, gid</i>) 
<b>Fs method</b> used to change the access and modification times of a file in the same way asfsPromises.utimes(), with the difference that if the path refers to asymbolic link, then the link is not dereferenced: instead, the timestamps ofthe symbolic link itself are changed. | fsPromises.lutimes(<i>path, atime, mtime</i>) 
<b>Fs method</b> used to create a new link from the existingPath to the newPath. See the POSIXlink(2) documentation for more detail. | fsPromises.link(<i>existingPath, newPath</i>) 
<b>Fs method</b> used to equivalent to fsPromises.stat() unless path refers to a symbolic link,in which case the link itself is stat-ed, not the file that it refers to.Refer to the POSIX lstat(2) document for more detail. | fsPromises.lstat(<i>path[, options]</i>) 
<b>Fs method</b> used to asynchronously creates a directory. the optional options argument can be an integer specifying mode (permissionand sticky bits), or an object with a mode property and a recursiveproperty indicating whether parent directories should be created. CallingfsPromises.mkdir() when path is a directory that exists results in arejection only when recursive is false. | fsPromises.mkdir(<i>path[, options]</i>) 
<b>Fs method</b> used to create a unique temporary directory. A unique directory name is generated byappending six random characters to the end of the provided prefix. Due toplatform inconsistencies, avoid trailing X characters in prefix. Someplatforms, notably the BSDs, can return more than six random characters, andreplace trailing X characters in prefix with random characters. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use. the fsPromises.mkdtemp() method will append the six randomly selectedcharacters directly to the prefix string. For instance, given a directory/tmp, if the intention is to create a temporary directory within /tmp, theprefix must end with a trailing platform-specific path separator(require('node:path').sep). | fsPromises.mkdtemp(<i>prefix[, options]</i>) 
<b>Fs method</b> used to open a <FileHandle>. refer to the POSIX open(2) documentation for more detail. some characters (< > : " / \ | ? *) are reserved under Windows as documentedby Naming Files, Paths, and Namespaces. Under NTFS, if the filename containsa colon, Node.js will open a file system stream, as described bythis MSDN page. | fsPromises.open(<i>path, flags[, mode]</i>) 
<b>Fs method</b> used to asynchronously open a directory for iterative scanning. See the POSIXopendir(3) documentation for more detail. create an <fs.Dir>, which contains all further functions for reading fromand cleaning up the directory. the encoding option sets the encoding for the path while opening thedirectory and subsequent read operations. example using async iteration: when using the async iterator, the <fs.Dir> object will be automaticallyclosed after the iterator exits. | fsPromises.opendir(<i>path[, options]</i>) 
<b>Fs method</b> used to read the contents of a directory. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe filenames. If the encoding is set to 'buffer', the filenames returnedwill be passed as <Buffer> objects. if options.withFileTypes is set to true, the resolved array will contain<fs.Dirent> objects. | fsPromises.readdir(<i>path[, options]</i>) 
<b>Fs method</b> used to asynchronously reads the entire contents of a file. if no encoding is specified (using options.encoding), the data is returnedas a <Buffer> object. Otherwise, the data will be a string. if options is a string, then it specifies the encoding. when the path is a directory, the behavior of fsPromises.readFile() isplatform-specific. On macOS, Linux, and Windows, the promise will be rejectedwith an error. On FreeBSD, a representation of the directory's contents will bereturned. an example of reading a package.json file located in the same directory of therunning code: it is possible to abort an ongoing readFile using an <AbortSignal>. If arequest is aborted the promise returned is rejected with an AbortError: aborting an ongoing request does not abort individual operatingsystem requests but rather the internal buffering fs.readFile performs. any specified <FileHandle> has to support reading. | fsPromises.readFile(<i>path[, options]</i>) 
<b>Fs method</b> used to read the contents of the symbolic link referred to by path. See the POSIXreadlink(2) documentation for more detail. The promise is resolved with thelinkString upon success. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe link path returned. If the encoding is set to 'buffer', the link pathreturned will be passed as a <Buffer> object. | fsPromises.readlink(<i>path[, options]</i>) 
<b>Fs method</b> used to determine the actual location of path using the same semantics as thefs.realpath.native() function. only paths that can be converted to UTF8 strings are supported. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe path. If the encoding is set to 'buffer', the path returned will bepassed as a <Buffer> object. on Linux, when Node.js is linked against musl libc, the procfs file system mustbe mounted on /proc in order for this function to work. Glibc does not havethis restriction. | fsPromises.realpath(<i>path[, options]</i>) 
<b>Fs method</b> used to rename oldPath to newPath. | fsPromises.rename(<i>oldPath, newPath</i>) 
<b>Fs method</b> used to remove the directory identified by path. using fsPromises.rmdir() on a file (not a directory) results in thepromise being rejected with an ENOENT error on Windows and an ENOTDIRerror on POSIX. to get a behavior similar to the rm -rf Unix command, usefsPromises.rm() with options { recursive: true, force: true }. | fsPromises.rmdir(<i>path[, options]</i>) 
<b>Fs method</b> used to remove files and directories (modeled on the standard POSIX rm utility). | fsPromises.rm(<i>path[, options]</i>) 
<b>Fs method</b> used to | fsPromises.stat(<i>path[, options]</i>) 
<b>Fs method</b> used to | fsPromises.statfs(<i>path[, options]</i>) 
<b>Fs method</b> used to create a symbolic link. the type argument is only used on Windows platforms and can be one of 'dir','file', or 'junction'. If the type argument is not a string, Node.js willautodetect target type and use 'file' or 'dir'. If the target does notexist, 'file' will be used. Windows junction points require the destinationpath to be absolute. When using 'junction', the target argument willautomatically be normalized to absolute path. Junction points on NTFS volumescan only point to directories. | fsPromises.symlink(<i>target, path[, type]</i>) 
<b>Fs method</b> used to truncate (shortens or extends the length) of the content at path to lenbytes. | fsPromises.truncate(<i>path[, len]</i>) 
<b>Fs method</b> used to if path refers to a symbolic link, then the link is removed without affectingthe file or directory to which that link refers. If the path refers to a filepath that is not a symbolic link, the file is deleted. See the POSIX unlink(2)documentation for more detail. | fsPromises.unlink(<i>path</i>) 
<b>Fs method</b> used to change the file system timestamps of the object referenced by path. the atime and mtime arguments follow these rules: | fsPromises.utimes(<i>path, atime, mtime</i>) 
<b>Fs method</b> used to return an async iterator that watches for changes on filename, where filenameis either a file or a directory. on most platforms, 'rename' is emitted whenever a filename appears ordisappears in the directory. all the caveats for fs.watch() also apply to fsPromises.watch(). | fsPromises.watch(<i>filename[, options]</i>) 
<b>Fs method</b> used to asynchronously writes data to a file, replacing the file if it already exists.data can be a string, a buffer, an <AsyncIterable>, or an <Iterable> object. the encoding option is ignored if data is a buffer. if options is a string, then it specifies the encoding. the mode option only affects the newly created file. See fs.open()for more details. any specified <FileHandle> has to support writing. it is unsafe to use fsPromises.writeFile() multiple times on the same filewithout waiting for the promise to be settled. similarly to fsPromises.readFile - fsPromises.writeFile is a conveniencemethod that performs multiple write calls internally to write the bufferpassed to it. For performance sensitive code consider usingfs.createWriteStream() or filehandle.createWriteStream(). it is possible to use an <AbortSignal> to cancel an fsPromises.writeFile().Cancelation is "best effort", and some amount of data is likely stillto be written. aborting an ongoing request does not abort individual operatingsystem requests but rather the internal buffering fs.writeFile performs. | fsPromises.writeFile(<i>file, data[, options]</i>) 
<b>Fs property</b> used to return an object containing commonly used constants for file systemoperations. The object is the same as fs.constants. See FS constantsfor more details. | fsPromises.constants 
<b>Fs method</b> used to test a user's permissions for the file or directory specified by path.The mode argument is an optional integer that specifies the accessibilitychecks to be performed. mode should be either the value fs.constants.F_OKor a mask consisting of the bitwise OR of any of fs.constants.R_OK,fs.constants.W_OK, and fs.constants.X_OK (e.g.fs.constants.W_OK | fs.constants.R_OK). Check File access constants forpossible values of mode. the final argument, callback, is a callback function that is invoked witha possible error argument. If any of the accessibility checks fail, the errorargument will be an Error object. The following examples check ifpackage.json exists, and if it is readable or writable. do not use fs.access() to check for the accessibility of a file before callingfs.open(), fs.readFile(), or fs.writeFile(). Doingso introduces a race condition, since other processes may change the file'sstate between the two calls. Instead, user code should open/read/write thefile directly and handle the error raised if the file is not accessible. write (NOT RECOMMENDED) write (RECOMMENDED) read (NOT RECOMMENDED) read (RECOMMENDED) the "not recommended" examples above check for accessibility and then use thefile; the "recommended" examples are better because they use the file directlyand handle the error, if any. in general, check for the accessibility of a file only if the file will not beused directly, for example when its accessibility is a signal from anotherprocess. on Windows, access-control policies (ACLs) on a directory may limit access toa file or directory. The fs.access() function, however, does not check theACL and therefore may report that a path is accessible even if the ACL restrictsthe user from reading or writing to it. | fs.access(<i>path[, mode], callback</i>) 
<b>Fs method</b> used to asynchronously append data to a file, creating the file if it does not yetexist. data can be a string or a <Buffer>. the mode option only affects the newly created file. See fs.open()for more details. if options is a string, then it specifies the encoding: the path may be specified as a numeric file descriptor that has been openedfor appending (using fs.open() or fs.openSync()). The file descriptor willnot be closed automatically. | fs.appendFile(<i>path, data[, options], callback</i>) 
<b>Fs method</b> used to asynchronously changes the permissions of a file. No arguments other than apossible exception are given to the completion callback. see the POSIX chmod(2) documentation for more detail. | fs.chmod(<i>path, mode, callback</i>) 
<b>Fs method</b> used to asynchronously changes owner and group of a file. No arguments other than apossible exception are given to the completion callback. see the POSIX chown(2) documentation for more detail. | fs.chown(<i>path, uid, gid, callback</i>) 
<b>Fs method</b> used to close the file descriptor. No arguments other than a possible exception aregiven to the completion callback. calling fs.close() on any file descriptor (fd) that is currently in usethrough any other fs operation may lead to undefined behavior. see the POSIX close(2) documentation for more detail. | fs.close(<i>fd[, callback]</i>) 
<b>Fs method</b> used to asynchronously copies src to dest. By default, dest is overwritten if italready exists. No arguments other than a possible exception are given to thecallback function. Node.js makes no guarantees about the atomicity of the copyoperation. If an error occurs after the destination file has been opened forwriting, Node.js will attempt to remove the destination. mode is an optional integer that specifies the behaviorof the copy operation. It is possible to create a mask consisting of the bitwiseOR of two or more values (e.g.fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE). | fs.copyFile(<i>src, dest[, mode], callback</i>) 
<b>Fs method</b> used to   asynchronously copies the entire directory structure from src to dest,including subdirectories and files. when copying a directory to another directory, globs are not supported andbehavior is similar to cp dir1/ dir2/. | fs.cp(<i>src, dest[, options], callback</i>) 
<b>Fs method</b> used to unlike the 16 KiB default highWaterMark for a <stream.Readable>, the streamreturned by this method has a default highWaterMark of 64 KiB. option can include start and end values to read a range of bytes fromthe file instead of the entire file. Both start and end are inclusive andstart counting at 0, allowed values are in the[0, Number.MAX_SAFE_INTEGER] range. If fd is specified and start isomitted or undefined, fs.createReadStream() reads sequentially from thecurrent file position. The encoding can be any one of those accepted by<Buffer>. if fd is specified, ReadStream will ignore the path argument and will usethe specified file descriptor. This means that no 'open' event will beemitted. fd should be blocking; non-blocking fds should be passed to<net.Socket>. if fd points to a character device that only supports blocking reads(such as keyboard or sound card), read operations do not finish until data isavailable. This can prevent the process from exiting and the stream fromclosing naturally. by default, the stream will emit a 'close' event after it has beendestroyed.  Set the emitClose option to false to change this behavior. by providing the fs option, it is possible to override the corresponding fsimplementations for open, read, and close. When providing the fs option,an override for read is required. If no fd is provided, an override foropen is also required. If autoClose is true, an override for close isalso required. if autoClose is false, then the file descriptor won't be closed, even ifthere's an error. It is the application's responsibility to close it and makesure there's no file descriptor leak. If autoClose is set to true (defaultbehavior), on 'error' or 'end' the file descriptor will be closedautomatically. mode sets the file mode (permission and sticky bits), but only if thefile was created. an example to read the last 10 bytes of a file which is 100 bytes long: if options is a string, then it specifies the encoding. | fs.createReadStream(<i>path[, options]</i>) 
<b>Fs method</b> used to option may also include a start option to allow writing data at someposition past the beginning of the file, allowed values are in the[0, Number.MAX_SAFE_INTEGER] range. Modifying a file rather thanreplacing it may require the flags option to be set to r+ rather than thedefault w. The encoding can be any one of those accepted by <Buffer>. if autoClose is set to true (default behavior) on 'error' or 'finish'the file descriptor will be closed automatically. If autoClose is false,then the file descriptor won't be closed, even if there's an error.It is the application's responsibility to close it and make sure there's nofile descriptor leak. by default, the stream will emit a 'close' event after it has beendestroyed.  Set the emitClose option to false to change this behavior. by providing the fs option it is possible to override the corresponding fsimplementations for open, write, writev, and close. Overriding write()without writev() can reduce performance as some optimizations (_writev())will be disabled. When providing the fs option, overrides for at least one ofwrite and writev are required. If no fd option is supplied, an overridefor open is also required. If autoClose is true, an override for closeis also required. like <fs.ReadStream>, if fd is specified, <fs.WriteStream> will ignore thepath argument and will use the specified file descriptor. This means that no'open' event will be emitted. fd should be blocking; non-blocking fdsshould be passed to <net.Socket>. if options is a string, then it specifies the encoding. | fs.createWriteStream(<i>path[, options]</i>) 
<b>Fs method</b> used to   test whether or not the given path exists by checking with the file system.Then call the callback argument with either true or false: the parameters for this callback are not consistent with other Node.jscallbacks. Normally, the first parameter to a Node.js callback is an errparameter, optionally followed by other parameters. The fs.exists() callbackhas only one boolean parameter. This is one reason fs.access() is recommendedinstead of fs.exists(). using fs.exists() to check for the existence of a file before callingfs.open(), fs.readFile(), or fs.writeFile() is not recommended. Doingso introduces a race condition, since other processes may change the file'sstate between the two calls. Instead, user code should open/read/write thefile directly and handle the error raised if the file does not exist. write (NOT RECOMMENDED) write (RECOMMENDED) read (NOT RECOMMENDED) read (RECOMMENDED) the "not recommended" examples above check for existence and then use thefile; the "recommended" examples are better because they use the file directlyand handle the error, if any. in general, check for the existence of a file only if the file won't beused directly, for example when its existence is a signal from anotherprocess. | fs.exists(<i>path, callback</i>) 
<b>Fs method</b> used to set the permissions on the file. No arguments other than a possible exceptionare given to the completion callback. see the POSIX fchmod(2) documentation for more detail. | fs.fchmod(<i>fd, mode, callback</i>) 
<b>Fs method</b> used to set the owner of the file. No arguments other than a possible exception aregiven to the completion callback. see the POSIX fchown(2) documentation for more detail. | fs.fchown(<i>fd, uid, gid, callback</i>) 
<b>Fs method</b> used to force all currently queued I/O operations associated with the file to theoperating system's synchronized I/O completion state. Refer to the POSIXfdatasync(2) documentation for details. No arguments other than a possibleexception are given to the completion callback. | fs.fdatasync(<i>fd, callback</i>) 
<b>Fs method</b> used to invoke the callback with the <fs.Stats> for the file descriptor. see the POSIX fstat(2) documentation for more detail. | fs.fstat(<i>fd[, options], callback</i>) 
<b>Fs method</b> used to request that all data for the open file descriptor is flushed to the storagedevice. The specific implementation is operating system and device specific.Refer to the POSIX fsync(2) documentation for more detail. No arguments otherthan a possible exception are given to the completion callback. | fs.fsync(<i>fd, callback</i>) 
<b>Fs method</b> used to truncate the file descriptor. No arguments other than a possible exception aregiven to the completion callback. see the POSIX ftruncate(2) documentation for more detail. if the file referred to by the file descriptor was larger than len bytes, onlythe first len bytes will be retained in the file. for example, the following program retains only the first four bytes of thefile: if the file previously was shorter than len bytes, it is extended, and theextended part is filled with null bytes ('\0'): if len is negative then 0 will be used. | fs.ftruncate(<i>fd[, len], callback</i>) 
<b>Fs method</b> used to change the file system timestamps of the object referenced by the supplied filedescriptor. See fs.utimes(). | fs.futimes(<i>fd, atime, mtime, callback</i>) 
<b>Fs method</b> used to change the permissions on a symbolic link. No arguments other than a possibleexception are given to the completion callback. thi method is only implemented on macOS. see the POSIX lchmod(2) documentation for more detail. | fs.lchmod(<i>path, mode, callback</i>) 
<b>Fs method</b> used to set the owner of the symbolic link. No arguments other than a possibleexception are given to the completion callback. see the POSIX lchown(2) documentation for more detail. | fs.lchown(<i>path, uid, gid, callback</i>) 
<b>Fs method</b> used to change the access and modification times of a file in the same way asfs.utimes(), with the difference that if the path refers to a symboliclink, then the link is not dereferenced: instead, the timestamps of thesymbolic link itself are changed. no arguments other than a possible exception are given to the completioncallback. | fs.lutimes(<i>path, atime, mtime, callback</i>) 
<b>Fs method</b> used to create a new link from the existingPath to the newPath. See the POSIXlink(2) documentation for more detail. No arguments other than a possibleexception are given to the completion callback. | fs.link(<i>existingPath, newPath, callback</i>) 
<b>Fs method</b> used to retrieve the <fs.Stats> for the symbolic link referred to by the path.The callback gets two arguments (err, stats) where stats is a <fs.Stats>object. lstat() is identical to stat(), except that if path is a symboliclink, then the link itself is stat-ed, not the file that it refers to. see the POSIX lstat(2) documentation for more details. | fs.lstat(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronously creates a directory. the callback is given a possible exception and, if recursive is true, thefirst directory path created, (err[, path]).path can still be undefined when recursive is true, if no directory wascreated (for instance, if it was previously created). the optional options argument can be an integer specifying mode (permissionand sticky bits), or an object with a mode property and a recursiveproperty indicating whether parent directories should be created. Callingfs.mkdir() when path is a directory that exists results in an error onlywhen recursive is false. If recursive is false and the directory exists,an EEXIST error occurs. on Windows, using fs.mkdir() on the root directory even with recursion willresult in an error: see the POSIX mkdir(2) documentation for more details. | fs.mkdir(<i>path[, options], callback</i>) 
<b>Fs method</b> used to create a unique temporary directory. generate six random characters to be appended behind a requiredprefix to create a unique temporary directory. Due to platforminconsistencies, avoid trailing X characters in prefix. Some platforms,notably the BSDs, can return more than six random characters, and replacetrailing X characters in prefix with random characters. the created directory path is passed as a string to the callback's secondparameter. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use. the fs.mkdtemp() method will append the six randomly selected charactersdirectly to the prefix string. For instance, given a directory /tmp, if theintention is to create a temporary directory within /tmp, the prefixmust end with a trailing platform-specific path separator(require('node:path').sep). | fs.mkdtemp(<i>prefix[, options], callback</i>) 
<b>Fs method</b> used to asynchronou file open. See the POSIX open(2) documentation for more details. mode sets the file mode (permission and sticky bits), but only if the file wascreated. On Windows, only the write permission can be manipulated; seefs.chmod(). the callback gets two arguments (err, fd). some characters (< > : " / \ | ? *) are reserved under Windows as documentedby Naming Files, Paths, and Namespaces. Under NTFS, if the filename containsa colon, Node.js will open a file system stream, as described bythis MSDN page. function based on fs.open() exhibit this behavior as well:fs.writeFile(), fs.readFile(), etc. | fs.open(<i>path[, flags[, mode]], callback</i>) 
<b>Fs method</b> used to   return a <Blob> whose data is backed by the given file. the file must not be modified after the <Blob> is created. Any modificationswill cause reading the <Blob> data to fail with a DOMException error.Synchronous stat operations on the file when the Blob is created, and beforeeach read in order to detect whether the file data has been modified on disk. | fs.openAsBlob(<i>path[, options]</i>) 
<b>Fs method</b> used to asynchronously open a directory. See the POSIX opendir(3) documentation formore details. create an <fs.Dir>, which contains all further functions for reading fromand cleaning up the directory. the encoding option sets the encoding for the path while opening thedirectory and subsequent read operations. | fs.opendir(<i>path[, options], callback</i>) 
<b>Fs method</b> used to read data from the file specified by fd. the callback is given the three arguments, (err, bytesRead, buffer). if the file is not modified concurrently, the end-of-file is reached when thenumber of bytes read is zero. if this method is invoked as its util.promisify()ed version, it returnsa promise for an Object with bytesRead and buffer properties. | fs.read(<i>fd, buffer, offset, length, position, callback</i>) 
<b>Fs method</b> used to similar to the fs.read() function, this version takes an optionaloptions object. If no options object is specified, it will default with theabove values. | fs.read(<i>fd[, options], callback</i>) 
<b>Fs method</b> used to similar to the fs.read() function, this version takes an optionaloptions object. If no options object is specified, it will default with theabove values. | fs.read(<i>fd, buffer[, options], callback</i>) 
<b>Fs method</b> used to read the contents of a directory. The callback gets two arguments (err, files)where files is an array of the names of the files in the directory excluding'.' and '..'. see the POSIX readdir(3) documentation for more details. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe filenames passed to the callback. If the encoding is set to 'buffer',the filenames returned will be passed as <Buffer> objects. if options.withFileTypes is set to true, the files array will contain<fs.Dirent> objects. | fs.readdir(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronously reads the entire contents of a file. the callback is passed two arguments (err, data), where data is thecontents of the file. if no encoding is specified, then the raw buffer is returned. if options is a string, then it specifies the encoding: when the path is a directory, the behavior of fs.readFile() andfs.readFileSync() is platform-specific. On macOS, Linux, and Windows, anerror will be returned. On FreeBSD, a representation of the directory's contentswill be returned. it is possible to abort an ongoing request using an AbortSignal. If arequest is aborted the callback is called with an AbortError: the fs.readFile() function buffers the entire file. To minimize memory costs,when possible prefer streaming via fs.createReadStream(). aborting an ongoing request does not abort individual operatingsystem requests but rather the internal buffering fs.readFile performs. | fs.readFile(<i>path[, options], callback</i>) 
<b>Fs method</b> used to read the contents of the symbolic link referred to by path. The callback getstwo arguments (err, linkString). see the POSIX readlink(2) documentation for more details. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe link path passed to the callback. If the encoding is set to 'buffer',the link path returned will be passed as a <Buffer> object. | fs.readlink(<i>path[, options], callback</i>) 
<b>Fs method</b> used to read from a file specified by fd and write to an array of ArrayBufferViewsusing readv(). position is the offset from the beginning of the file from where datashould be read. If typeof position !== 'number', the data will be readfrom the current position. the callback will be given three arguments: err, bytesRead, andbuffers. bytesRead is how many bytes were read from the file. if this method is invoked as its util.promisify()ed version, it returnsa promise for an Object with bytesRead and buffers properties. | fs.readv(<i>fd, buffers[, position], callback</i>) 
<b>Fs method</b> used to asynchronously computes the canonical pathname by resolving ., .., andsymbolic links. a canonical pathname is not necessarily unique. Hard links and bind mounts canexpose a file system entity through many pathnames. thi function behaves like realpath(3), with some exceptions: the callback gets two arguments (err, resolvedPath). May use process.cwdto resolve relative paths. only paths that can be converted to UTF8 strings are supported. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe path passed to the callback. If the encoding is set to 'buffer',the path returned will be passed as a <Buffer> object. if path resolves to a socket or a pipe, the function will return a systemdependent name for that object. | fs.realpath(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronou realpath(3). the callback gets two arguments (err, resolvedPath). only paths that can be converted to UTF8 strings are supported. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe path passed to the callback. If the encoding is set to 'buffer',the path returned will be passed as a <Buffer> object. on Linux, when Node.js is linked against musl libc, the procfs file system mustbe mounted on /proc in order for this function to work. Glibc does not havethis restriction. | fs.realpath.native(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronously rename file at oldPath to the pathname providedas newPath. In the case that newPath already exists, it willbe overwritten. If there is a directory at newPath, an error willbe raised instead. No arguments other than a possible exception aregiven to the completion callback. see also: rename(2). | fs.rename(<i>oldPath, newPath, callback</i>) 
<b>Fs method</b> used to asynchronou rmdir(2). No arguments other than a possible exception are givento the completion callback. using fs.rmdir() on a file (not a directory) results in an ENOENT error onWindows and an ENOTDIR error on POSIX. to get a behavior similar to the rm -rf Unix command, use fs.rm()with options { recursive: true, force: true }. | fs.rmdir(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronously removes files and directories (modeled on the standard POSIX rmutility). No arguments other than a possible exception are given to thecompletion callback. | fs.rm(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronou stat(2). The callback gets two arguments (err, stats) wherestats is an <fs.Stats> object. in case of an error, the err.code will be one of Common System Errors. fs.stat() follows symbolic links. Use fs.lstat() to look at thelinks themselves. using fs.stat() to check for the existence of a file before callingfs.open(), fs.readFile(), or fs.writeFile() is not recommended.Instead, user code should open/read/write the file directly and handle theerror raised if the file is not available. to check if a file exists without manipulating it afterwards, fs.access()is recommended. for example, given the following directory structure: the next program will check for the stats of the given paths: the resulting output will resemble: | fs.stat(<i>path[, options], callback</i>) 
<b>Fs method</b> used to asynchronou statfs(2). Returns information about the mounted file system whichcontains path. The callback gets two arguments (err, stats) where statsis an <fs.StatFs> object. in case of an error, the err.code will be one of Common System Errors. | fs.statfs(<i>path[, options], callback</i>) 
<b>Fs method</b> used to create the link called path pointing to target. No arguments other than apossible exception are given to the completion callback. see the POSIX symlink(2) documentation for more details. the type argument is only available on Windows and ignored on other platforms.It can be set to 'dir', 'file', or 'junction'. If the type argument isnot a string, Node.js will autodetect target type and use 'file' or 'dir'.If the target does not exist, 'file' will be used. Windows junction pointsrequire the destination path to be absolute. When using 'junction', thetarget argument will automatically be normalized to absolute path. Junctionpoints on NTFS volumes can only point to directories. relative targets are relative to the link's parent directory. the above example creates a symbolic link mewtwo which points to mew in thesame directory: | fs.symlink(<i>target, path[, type], callback</i>) 
<b>Fs method</b> used to truncate the file. No arguments other than a possible exception aregiven to the completion callback. A file descriptor can also be passed as thefirst argument. In this case, fs.ftruncate() is called. passing a file descriptor is deprecated and may result in an error being thrownin the future. see the POSIX truncate(2) documentation for more details. | fs.truncate(<i>path[, len], callback</i>) 
<b>Fs method</b> used to asynchronously removes a file or symbolic link. No arguments other than apossible exception are given to the completion callback. fs.unlink() will not work on a directory, empty or otherwise. To remove adirectory, use fs.rmdir(). see the POSIX unlink(2) documentation for more details. | fs.unlink(<i>path, callback</i>) 
<b>Fs method</b> used to stop watching for changes on filename. If listener is specified, only thatparticular listener is removed. Otherwise, all listeners are removed,effectively stopping watching of filename. calling fs.unwatchFile() with a filename that is not being watched is ano-op, not an error. using fs.watch() is more efficient than fs.watchFile() andfs.unwatchFile(). fs.watch() should be used instead of fs.watchFile()and fs.unwatchFile() when possible. | fs.unwatchFile(<i>filename[, listener]</i>) 
<b>Fs method</b> used to change the file system timestamps of the object referenced by path. the atime and mtime arguments follow these rules: | fs.utimes(<i>path, atime, mtime, callback</i>) 
<b>Fs method</b> used to watch for changes on filename, where filename is either a file or adirectory. the second argument is optional. If options is provided as a string, itspecifies the encoding. Otherwise options should be passed as an object. the listener callback gets two arguments (eventType, filename). eventTypeis either 'rename' or 'change', and filename is the name of the filewhich triggered the event. on most platforms, 'rename' is emitted whenever a filename appears ordisappears in the directory. the listener callback is attached to the 'change' event fired by<fs.FSWatcher>, but it is not the same thing as the 'change' value ofeventType. if a signal is passed, aborting the corresponding AbortController will closethe returned <fs.FSWatcher>. | fs.watch(<i>filename[, options][, listener]</i>) 
<b>Fs method</b> used to watch for changes on filename. The callback listener will be called eachtime the file is accessed. the options argument may be omitted. If provided, it should be an object. Theoptions object may contain a boolean named persistent that indicateswhether the process should continue to run as long as files are being watched.The options object may specify an interval property indicating how often thetarget should be polled in milliseconds. the listener gets two arguments the current stat object and the previousstat object: these stat objects are instances of fs.Stat. If the bigint option is true,the numeric values in these objects are specified as BigInts. to be notified when the file was modified, not just accessed, it is necessaryto compare curr.mtimeMs and prev.mtimeMs. when an fs.watchFile operation results in an ENOENT error, itwill invoke the listener once, with all the fields zeroed (or, for dates, theUnix Epoch). If the file is created later on, the listener will be calledagain, with the latest stat objects. This is a change in functionality sincev0.10. using fs.watch() is more efficient than fs.watchFile andfs.unwatchFile. fs.watch should be used instead of fs.watchFile andfs.unwatchFile when possible. when a file being watched by fs.watchFile() disappears and reappears,then the contents of previous in the second callback event (the file'sreappearance) will be the same as the contents of previous in the firstcallback event (its disappearance). thi happens when: | fs.watchFile(<i>filename[, options], listener</i>) 
<b>Fs method</b> used to write buffer to the file specified by fd. offset determines the part of the buffer to be written, and length isan integer specifying the number of bytes to write. position refers to the offset from the beginning of the file where this datashould be written. If typeof position !== 'number', the data will be writtenat the current position. See pwrite(2). the callback will be given three arguments (err, bytesWritten, buffer) wherebytesWritten specifies how many bytes were written from buffer. if this method is invoked as its util.promisify()ed version, it returnsa promise for an Object with bytesWritten and buffer properties. it is unsafe to use fs.write() multiple times on the same file without waitingfor the callback. For this scenario, fs.createWriteStream() isrecommended. on Linux, positional writes don't work when the file is opened in append mode.The kernel ignores the position argument and always appends the data tothe end of the file. | fs.write(<i>fd, buffer, offset[, length[, position]], callback</i>) 
<b>Fs method</b> used to write buffer to the file specified by fd. similar to the above fs.write function, this version takes anoptional options object. If no options object is specified, it willdefault with the above values. | fs.write(<i>fd, buffer[, options], callback</i>) 
<b>Fs method</b> used to write string to the file specified by fd. If string is not a string,an exception is thrown. position refers to the offset from the beginning of the file where this datashould be written. If typeof position !== 'number' the data will be written atthe current position. See pwrite(2). encoding is the expected string encoding. the callback will receive the arguments (err, written, string) where writtenspecifies how many bytes the passed string required to be written. Byteswritten is not necessarily the same as string characters written. SeeBuffer.byteLength. it is unsafe to use fs.write() multiple times on the same file without waitingfor the callback. For this scenario, fs.createWriteStream() isrecommended. on Linux, positional writes don't work when the file is opened in append mode.The kernel ignores the position argument and always appends the data tothe end of the file. on Windows, if the file descriptor is connected to the console (e.g. fd == 1or stdout) a string containing non-ASCII characters will not be renderedproperly by default, regardless of the encoding used.It is possible to configure the console to render UTF-8 properly by changing theactive codepage with the chcp 65001 command. See the chcp docs for moredetails. | fs.write(<i>fd, string[, position[, encoding]], callback</i>) 
<b>Fs method</b> used to when file is a filename, asynchronously writes data to the file, replacing thefile if it already exists. data can be a string or a buffer. when file is a file descriptor, the behavior is similar to callingfs.write() directly (which is recommended). See the notes below on usinga file descriptor. the encoding option is ignored if data is a buffer. the mode option only affects the newly created file. See fs.open()for more details. if options is a string, then it specifies the encoding: it is unsafe to use fs.writeFile() multiple times on the same file withoutwaiting for the callback. For this scenario, fs.createWriteStream() isrecommended. similarly to fs.readFile - fs.writeFile is a convenience method thatperforms multiple write calls internally to write the buffer passed to it.For performance sensitive code consider using fs.createWriteStream(). it is possible to use an <AbortSignal> to cancel an fs.writeFile().Cancelation is "best effort", and some amount of data is likely stillto be written. aborting an ongoing request does not abort individual operatingsystem requests but rather the internal buffering fs.writeFile performs. | fs.writeFile(<i>file, data[, options], callback</i>) 
<b>Fs method</b> used to write an array of ArrayBufferViews to the file specified by fd usingwritev(). position is the offset from the beginning of the file where this datashould be written. If typeof position !== 'number', the data will be writtenat the current position. the callback will be given three arguments: err, bytesWritten, andbuffers. bytesWritten is how many bytes were written from buffers. if this method is util.promisify()ed, it returns a promise for anObject with bytesWritten and buffers properties. it is unsafe to use fs.writev() multiple times on the same file withoutwaiting for the callback. For this scenario, use fs.createWriteStream(). on Linux, positional writes don't work when the file is opened in append mode.The kernel ignores the position argument and always appends the data tothe end of the file. | fs.writev(<i>fd, buffers[, position], callback</i>) 
<b>Fs method</b> used to synchronously tests a user's permissions for the file or directory specifiedby path. The mode argument is an optional integer that specifies theaccessibility checks to be performed. mode should be either the valuefs.constants.F_OK or a mask consisting of the bitwise OR of any offs.constants.R_OK, fs.constants.W_OK, and fs.constants.X_OK (e.g.fs.constants.W_OK | fs.constants.R_OK). Check File access constants forpossible values of mode. if any of the accessibility checks fail, an Error will be thrown. Otherwise,the method will return undefined. | fs.accessSync(<i>path[, mode]</i>) 
<b>Fs method</b> used to synchronously append data to a file, creating the file if it does not yetexist. data can be a string or a <Buffer>. the mode option only affects the newly created file. See fs.open()for more details. if options is a string, then it specifies the encoding: the path may be specified as a numeric file descriptor that has been openedfor appending (using fs.open() or fs.openSync()). The file descriptor willnot be closed automatically. | fs.appendFileSync(<i>path, data[, options]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.chmod(). see the POSIX chmod(2) documentation for more detail. | fs.chmodSync(<i>path, mode</i>) 
<b>Fs method</b> used to synchronously changes owner and group of a file. Returns undefined.This is the synchronous version of fs.chown(). see the POSIX chown(2) documentation for more detail. | fs.chownSync(<i>path, uid, gid</i>) 
<b>Fs method</b> used to close the file descriptor. Returns undefined. calling fs.closeSync() on any file descriptor (fd) that is currently in usethrough any other fs operation may lead to undefined behavior. see the POSIX close(2) documentation for more detail. | fs.closeSync(<i>fd</i>) 
<b>Fs method</b> used to synchronously copies src to dest. By default, dest is overwritten if italready exists. Returns undefined. Node.js makes no guarantees about theatomicity of the copy operation. If an error occurs after the destination filehas been opened for writing, Node.js will attempt to remove the destination. mode is an optional integer that specifies the behaviorof the copy operation. It is possible to create a mask consisting of the bitwiseOR of two or more values (e.g.fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE). | fs.copyFileSync(<i>src, dest[, mode]</i>) 
<b>Fs method</b> used to   synchronously copies the entire directory structure from src to dest,including subdirectories and files. when copying a directory to another directory, globs are not supported andbehavior is similar to cp dir1/ dir2/. | fs.cpSync(<i>src, dest[, options]</i>) 
<b>Fs method</b> used to return true if the path exists, false otherwise. for detailed information, see the documentation of the asynchronous version ofthis API: fs.exists(). fs.exists() is deprecated, but fs.existsSync() is not. The callbackparameter to fs.exists() accepts parameters that are inconsistent with otherNode.js callbacks. fs.existsSync() does not use a callback. | fs.existsSync(<i>path</i>) 
<b>Fs method</b> used to set the permissions on the file. Returns undefined. see the POSIX fchmod(2) documentation for more detail. | fs.fchmodSync(<i>fd, mode</i>) 
<b>Fs method</b> used to set the owner of the file. Returns undefined. see the POSIX fchown(2) documentation for more detail. | fs.fchownSync(<i>fd, uid, gid</i>) 
<b>Fs method</b> used to force all currently queued I/O operations associated with the file to theoperating system's synchronized I/O completion state. Refer to the POSIXfdatasync(2) documentation for details. Returns undefined. | fs.fdatasyncSync(<i>fd</i>) 
<b>Fs method</b> used to retrieve the <fs.Stats> for the file descriptor. see the POSIX fstat(2) documentation for more detail. | fs.fstatSync(<i>fd[, options]</i>) 
<b>Fs method</b> used to request that all data for the open file descriptor is flushed to the storagedevice. The specific implementation is operating system and device specific.Refer to the POSIX fsync(2) documentation for more detail. Returns undefined. | fs.fsyncSync(<i>fd</i>) 
<b>Fs method</b> used to truncate the file descriptor. Returns undefined. for detailed information, see the documentation of the asynchronous version ofthis API: fs.ftruncate(). | fs.ftruncateSync(<i>fd[, len]</i>) 
<b>Fs method</b> used to synchronou version of fs.futimes(). Returns undefined. | fs.futimesSync(<i>fd, atime, mtime</i>) 
<b>Fs method</b> used to change the permissions on a symbolic link. Returns undefined. thi method is only implemented on macOS. see the POSIX lchmod(2) documentation for more detail. | fs.lchmodSync(<i>path, mode</i>) 
<b>Fs method</b> used to set the owner for the path. Returns undefined. see the POSIX lchown(2) documentation for more details. | fs.lchownSync(<i>path, uid, gid</i>) 
<b>Fs method</b> used to change the file system timestamps of the symbolic link referenced by path.Returns undefined, or throws an exception when parameters are incorrect orthe operation fails. This is the synchronous version of fs.lutimes(). | fs.lutimesSync(<i>path, atime, mtime</i>) 
<b>Fs method</b> used to create a new link from the existingPath to the newPath. See the POSIXlink(2) documentation for more detail. Returns undefined. | fs.linkSync(<i>existingPath, newPath</i>) 
<b>Fs method</b> used to retrieve the <fs.Stats> for the symbolic link referred to by path. see the POSIX lstat(2) documentation for more details. | fs.lstatSync(<i>path[, options]</i>) 
<b>Fs method</b> used to synchronously creates a directory. Returns undefined, or if recursive istrue, the first directory path created.This is the synchronous version of fs.mkdir(). see the POSIX mkdir(2) documentation for more details. | fs.mkdirSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return the created directory path. for detailed information, see the documentation of the asynchronous version ofthis API: fs.mkdtemp(). the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use. | fs.mkdtempSync(<i>prefix[, options]</i>) 
<b>Fs method</b> used to synchronously open a directory. See opendir(3). create an <fs.Dir>, which contains all further functions for reading fromand cleaning up the directory. the encoding option sets the encoding for the path while opening thedirectory and subsequent read operations. | fs.opendirSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return an integer representing the file descriptor. for detailed information, see the documentation of the asynchronous version ofthis API: fs.open(). | fs.openSync(<i>path[, flags[, mode]]</i>) 
<b>Fs method</b> used to read the contents of the directory. see the POSIX readdir(3) documentation for more details. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe filenames returned. If the encoding is set to 'buffer',the filenames returned will be passed as <Buffer> objects. if options.withFileTypes is set to true, the result will contain<fs.Dirent> objects. | fs.readdirSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return the contents of the path. for detailed information, see the documentation of the asynchronous version ofthis API: fs.readFile(). if the encoding option is specified then this function returns astring. Otherwise it returns a buffer. similar to fs.readFile(), when the path is a directory, the behavior offs.readFileSync() is platform-specific. | fs.readFileSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return the symbolic link's string value. see the POSIX readlink(2) documentation for more details. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe link path returned. If the encoding is set to 'buffer',the link path returned will be passed as a <Buffer> object. | fs.readlinkSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return the number of bytesRead. for detailed information, see the documentation of the asynchronous version ofthis API: fs.read(). | fs.readSync(<i>fd, buffer, offset, length[, position]</i>) 
<b>Fs method</b> used to return the number of bytesRead. similar to the above fs.readSync function, this version takes an optional options object.If no options object is specified, it will default with the above values. for detailed information, see the documentation of the asynchronous version ofthis API: fs.read(). | fs.readSync(<i>fd, buffer[, options]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.readv(). | fs.readvSync(<i>fd, buffers[, position]</i>) 
<b>Fs method</b> used to return the resolved pathname. for detailed information, see the documentation of the asynchronous version ofthis API: fs.realpath(). | fs.realpathSync(<i>path[, options]</i>) 
<b>Fs method</b> used to synchronou realpath(3). only paths that can be converted to UTF8 strings are supported. the optional options argument can be a string specifying an encoding, or anobject with an encoding property specifying the character encoding to use forthe path returned. If the encoding is set to 'buffer',the path returned will be passed as a <Buffer> object. on Linux, when Node.js is linked against musl libc, the procfs file system mustbe mounted on /proc in order for this function to work. Glibc does not havethis restriction. | fs.realpathSync.native(<i>path[, options]</i>) 
<b>Fs method</b> used to rename the file from oldPath to newPath. Returns undefined. see the POSIX rename(2) documentation for more details. | fs.renameSync(<i>oldPath, newPath</i>) 
<b>Fs method</b> used to synchronou rmdir(2). Returns undefined. using fs.rmdirSync() on a file (not a directory) results in an ENOENT erroron Windows and an ENOTDIR error on POSIX. to get a behavior similar to the rm -rf Unix command, use fs.rmSync()with options { recursive: true, force: true }. | fs.rmdirSync(<i>path[, options]</i>) 
<b>Fs method</b> used to synchronously removes files and directories (modeled on the standard POSIX rmutility). Returns undefined. | fs.rmSync(<i>path[, options]</i>) 
<b>Fs method</b> used to retrieve the <fs.Stats> for the path. | fs.statSync(<i>path[, options]</i>) 
<b>Fs method</b> used to synchronou statfs(2). Returns information about the mounted file system whichcontains path. in case of an error, the err.code will be one of Common System Errors. | fs.statfsSync(<i>path[, options]</i>) 
<b>Fs method</b> used to return undefined. for detailed information, see the documentation of the asynchronous version ofthis API: fs.symlink(). | fs.symlinkSync(<i>target, path[, type]</i>) 
<b>Fs method</b> used to truncate the file. Returns undefined. A file descriptor can also bepassed as the first argument. In this case, fs.ftruncateSync() is called. passing a file descriptor is deprecated and may result in an error being thrownin the future. | fs.truncateSync(<i>path[, len]</i>) 
<b>Fs method</b> used to synchronou unlink(2). Returns undefined. | fs.unlinkSync(<i>path</i>) 
<b>Fs method</b> used to return undefined. for detailed information, see the documentation of the asynchronous version ofthis API: fs.utimes(). | fs.utimesSync(<i>path, atime, mtime</i>) 
<b>Fs method</b> used to return undefined. the mode option only affects the newly created file. See fs.open()for more details. for detailed information, see the documentation of the asynchronous version ofthis API: fs.writeFile(). | fs.writeFileSync(<i>file, data[, options]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.write(fd, buffer...). | fs.writeSync(<i>fd, buffer, offset[, length[, position]]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.write(fd, buffer...). | fs.writeSync(<i>fd, buffer[, options]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.write(fd, string...). | fs.writeSync(<i>fd, string[, position[, encoding]]</i>) 
<b>Fs method</b> used to for detailed information, see the documentation of the asynchronous version ofthis API: fs.writev(). | fs.writevSync(<i>fd, buffers[, position]</i>) 
<b>Fs property</b> used to a class representing a directory stream. created by fs.opendir(), fs.opendirSync(), orfsPromises.opendir(). when using the async iterator, the <fs.Dir> object will be automaticallyclosed after the iterator exits. | fs.Dir 
<b>Fs property</b> used to a representation of a directory entry, which can be a file or a subdirectorywithin the directory, as returned by reading from an <fs.Dir>. Thedirectory entry is a combination of the file name and file type pairs. additionally, when fs.readdir() or fs.readdirSync() is called withthe withFileTypes option set to true, the resulting array is filled with<fs.Dirent> objects, rather than strings or <Buffer>s. | fs.Dirent 
<b>Fs property</b> used to a successful call to fs.watch() method will return a new <fs.FSWatcher>object. all <fs.FSWatcher> objects emit a 'change' event whenever a specific watchedfile is modified. | fs.FSWatcher 
<b>Fs property</b> used to a successful call to fs.watchFile() method will return a new <fs.StatWatcher>object. | fs.StatWatcher 
<b>Fs property</b> used to instance of <fs.ReadStream> are created and returned using thefs.createReadStream() function. | fs.ReadStream 
<b>Fs property</b> used to a <fs.Stats> object provides information about a file. object returned from fs.stat(), fs.lstat(), fs.fstat(), andtheir synchronous counterparts are of this type.If bigint in the options passed to those methods is true, the numeric valueswill be bigint instead of number, and the object will contain additionalnanosecond-precision properties suffixed with Ns. bigint version: | fs.Stats 
<b>Fs property</b> used to provide information about a mounted file system. object returned from fs.statfs() and its synchronous counterpart are ofthis type. If bigint in the options passed to those methods is true, thenumeric values will be bigint instead of number. bigint version: | fs.StatFs 
<b>Fs property</b> used to instance of <fs.WriteStream> are created and returned using thefs.createWriteStream() function. | fs.WriteStream 
<b>Fs property</b> used to return an object containing commonly used constants for file systemoperations. | fs.constants 
