<i>File</i>.Chdir(<i></i>) | <b>Os function</b> that changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError.  |  | func (f *File) Chdir() error 
<i>File</i>.Chmod(<i>mode</i>) | <b>Os function</b> that changes the mode of the file to mode. If there is an error, it will be of type *PathError.  |  | func (f *File) Chmod(mode FileMode) error 
<i>File</i>.Chown(<i>uid</i>, <i>gid</i>) | <b>Os function</b> that changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError.  |  | func (f *File) Chown(uid, gid int) error 
<i>File</i>.Close(<i></i>) | <b>Os function</b> that closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an ErrClosed error. Close will return an error if it has already been called.  |  | func (f *File) Close() error 
<i>File</i>.Fd(<i></i>) | <b>Os function</b> that returns the integer Unix file descriptor referencing the open file. If f is closed, the file descriptor becomes invalid. If f is garbage collected, a finalizer may close the file descriptor, making it invalid; see runtime.SetFinalizer for more information on when a finalizer might be run. On Unix systems this will cause the SetDeadline methods to stop working. Because file descriptors can be reused, the returned file descriptor may only be closed through the Close method of f, or by its finalizer during garbage collection. Otherwise, during garbage collection the finalizer may close an unrelated file descriptor with the same (reused) number.  |  | func (f *File) Fd() uintptr 
<i>File</i>.Name(<i></i>) | <b>Os function</b> that returns the name of the file as presented to Open.  |  | func (f *File) Name() string 
<i>File</i>.Read(<i>b</i>) | <b>Os function</b> that reads up to len(b) bytes from the File and stores them in b. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.  |  | func (f *File) Read(b []byte) (n int, err error) 
<i>File</i>.ReadAt(<i>b</i>, <i>off</i>) | <b>Os function</b> that reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n < len(b). At end of file, that error is io.EOF.  |  | func (f *File) ReadAt(b []byte, off int64) (n int, err error) 
<i>File</i>.ReadDir(<i>n</i>) | <b>Os function</b> that reads the contents of the directory associated with the file f and returns a slice of DirEntry values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory.  |  | func (f *File) ReadDir(n int) ([]DirEntry, error) 
<i>File</i>.ReadFrom(<i>r</i>) | <b>Os function</b> that implements io.ReaderFrom.  |  | func (f *File) ReadFrom(r io.Reader) (n int64, err error) 
<i>File</i>.Readdir(<i>n</i>) | <b>Os function</b> that reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.  |  | func (f *File) Readdir(n int) ([]FileInfo, error) 
<i>File</i>.Readdirnames(<i>n</i>) | <b>Os function</b> that reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.  |  | func (f *File) Readdirnames(n int) (names []string, err error) 
<i>File</i>.Seek(<i>offset</i>, <i>whence</i>) | <b>Os function</b> that sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.  |  | func (f *File) Seek(offset int64, whence int) (ret int64, err error) 
<i>File</i>.SetDeadline(<i>t</i>) | <b>Os function</b> that sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.  |  | func (f *File) SetDeadline(t time.Time) error 
<i>File</i>.SetReadDeadline(<i>t</i>) | <b>Os function</b> that sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.  |  | func (f *File) SetReadDeadline(t time.Time) error 
<i>File</i>.SetWriteDeadline(<i>t</i>) | <b>Os function</b> that sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n > 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.  |  | func (f *File) SetWriteDeadline(t time.Time) error 
<i>File</i>.Stat(<i></i>) | <b>Os function</b> that returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.  |  | func (f *File) Stat() (FileInfo, error) 
<i>File</i>.Sync(<i></i>) | <b>Os function</b> that commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.  |  | func (f *File) Sync() error 
<i>File</i>.SyscallConn(<i></i>) | <b>Os function</b> that returns a raw file. This implements the syscall.Conn interface.  |  | func (f *File) SyscallConn() (syscall.RawConn, error) 
<i>File</i>.Truncate(<i>size</i>) | <b>Os function</b> that changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.  |  | func (f *File) Truncate(size int64) error 
<i>File</i>.Write(<i>b</i>) | <b>Os function</b> that writes len(b) bytes from b to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b).  |  | func (f *File) Write(b []byte) (n int, err error) 
<i>File</i>.WriteAt(<i>b</i>, <i>off</i>) | <b>Os function</b> that writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b).  |  | func (f *File) WriteAt(b []byte, off int64) (n int, err error) 
<i>File</i>.WriteString(<i>s</i>) | <b>Os function</b> that is like Write, but writes the contents of string s rather than a slice of bytes.  |  | func (f *File) WriteString(s string) (n int, err error) 
